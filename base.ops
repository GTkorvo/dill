#!perl

sub upperc {
    local($_) = pop(@_);
    tr/[a-z]/[A-Z]/;
    return $_;
}

&init_output;

    $arith3 = 0;
&arith3( "add sub mul div mod xor and or lsh rsh", "i u ul l");
&arith3( "add sub", "p");
&arith3( "add sub mul div", "f d");
    $arith2 = 0;
&arith2( "not com neg", "i u ul l");
&arith2( "bswap", "s us i u ul l f d");
&arith2( "neg", "f d");
    $branch = 0;
&branch( "eq ge gt le lt ne", "i u ul l p d f");
    $convert = 0;
&convert( "c d f i l s u ul us uc", "i u ul l");
&convert( "d f i l u ul", "f d");
&convert( "i l u ul", "c s");
&convert( "p ul", "ul p");
&loadstore("c d f i l p s u uc u ul us");
&ret("c uc s us i u l ul p d f");
&mov("c uc s us i u l ul p d f");
&set("c uc s us i u l ul p d f");
&push("i u l ul p f d");
&call("i u l ul p f d v");
&save_restore("i u l ul p d f");

print HOUT "#define dill_jmp_a3_size $arith3\n";
print HOUT "#define dill_jmp_a2_size $arith2\n";
print HOUT "#define dill_jmp_branch_size $branch\n";
print HOUT "#define dill_jmp_convert_size $convert\n";

print HOUT "#define dill_jv(c, label) (c->j->jv)(c, (unsigned long) label)\n";
print HOUT "#define dill_jp(c, dest_reg) (c->j->jp)(c, (unsigned long) dest_reg)\n";
print HOUT "#define dill_jpi(c, dest_imm) (c->j->jpi)(c, dest_imm)\n";
print HOUT "#define dill_jalp(c, return_addill_reg, target) (c->j->jal)(c, return_addill_reg, target)\n";

print HOUT "#define dill_special(c, type, param) if (c->j->special) (c->j->special)(c, type, param)\n";

print COUT "\n/* This file is generated from base.ops.  Do not edit directly. */\n\n";
print COUT "#include <dill.h>\n";
print COUT "\nchar *arith3_name[] = \{".substr($enum_a3,2). "\};\n";
print COUT "\nchar *arith2_name[] = \{".substr($enum_a2,2). "\};\n";
foreach $key (keys %poly_array) {
   $poly_array{$key} .= " ";
   print COUT "int dill_${key}_poly_map[] = {\n";
   print HOUT "extern int dill_${key}_poly_map[];\n";
   print HOUT "#define dill_P$key(c, typ, dest, src1, src2) (c->j->jmp_a3)[dill_${key}_poly_map[typ]](c, c->j->a3_data[dill_${key}_poly_map[typ]].data1, c->j->a3_data[dill_${key}_poly_map[typ]].data2, dest, src1, src2)\n";
   foreach (split(' ', "c uc s us i u l ul p f d v b")) {
       $typ = $_;
       if ($poly_array{$key} =~ m/\W$typ\W/) {
	   print COUT ("dill_jmp_$key$typ, ");
       } else {
	   if (substr ($typ, 0, 1) eq "u") {
	       print COUT ("dill_jmp_${key}ul, ");
	   } else {
	       print COUT ("dill_jmp_${key}l, ");
	   }
       }
   }
   print COUT "0};\n";
}
foreach $key (keys %poly_branch_array) {
   $poly_branch_array{$key} .= " ";
   print COUT "int dill_${key}_poly_map[] = {\n";
   print HOUT "extern int dill_b${key}_poly_map[];\n";
   print HOUT "#define dill_Pb$key(c, typ, dest, src1, src2) (c->j->jmp_b)[dill_b${key}_poly_map[typ]](c, c->j->b_data[dill_b${key}_poly_map[typ]].data1, c->j->b_data[dill_b${key}_poly_map[typ]].data2, src1, src2, label)\n";
   foreach (split(' ', "c uc s us i u l ul p f d v b")) {
       $typ = $_;
       if ($poly_branch_array{$key} =~ m/\W$typ\W/) {
	   print COUT ("dill_jmp_b$key$typ, ");
       } else {
	   if (substr ($typ, 0, 1) eq "u") {
	       print COUT ("dill_jmp_b${key}ul, ");
	   } else {
	       print COUT ("dill_jmp_b${key}l, ");
	   }
       }
   }
   print COUT "0};\n";
}

print HOUT<<EOF;
#if defined(__cplusplus) || defined(c_plusplus)
}
#endif
#endif /* __DILL_H__ */

EOF

print COUT <<EOF;
char *dill_type_names[] = {
    "c",    /* char */
    "uc",   /* unsigned char */
    "s",    /* short */
    "us",   /* unsigned short */
    "i",    /* int */
    "u",    /* unsigned */
    "l",    /* long */
    "ul",   /* unsigned long */
    "p",    /* pointer */
    "f",    /* floating */
    "d",    /* double */
    "v",    /* void */
    "b",    /* block structure */
};
EOF

sub loadstore {
    local ($types) = @_;
    print HOUT "#define dill_Pload(c, typ, dest, src1, src2) (c->j->load)(c, typ, 0, dest, src1, src2)\n";
    print HOUT "#define dill_Ploadi(c, typ, dest, src, imm) (c->j->loadi)(c, typ, 0, dest, src, imm)\n";
    print HOUT "#define dill_Pstore(c, typ, dest, src1, src2) (c->j->store)(c, typ, 0, dest, src1, src2)\n";
    print HOUT "#define dill_Pstorei(c, typ, dest, src, imm) (c->j->storei)(c, typ, 0, dest, src, imm)\n";
    foreach (split(' ', $types)) {
	print VHOUT "#define dill_ld${_}(c, dest, src1, src2) v_ld${_}(dest, src1, src2)\n";
	print VHOUT "#define dill_ld${_}i(c, dest, src1, imm) v_ld${_}i(dest, src1, imm)\n";
	print IHOUT "#define dill_ld${_}(c, dest, src1, src2) i_ld${_}(dest, src1, src2)\n";
	print IHOUT "#define dill_ld${_}i(c, dest, src1, imm) i_ld${_}i(dest, src1, imm)\n";
	print HOUT "#define dill_ld${_}(c, dest, src1, src2) (c->j->load)(c, DILL_" . &upperc($_) . ", 0, dest, src1, src2)\n";
	print HOUT "#define dill_ld${_}i(c, dest, src, imm) (c->j->loadi)(c, DILL_" . &upperc($_) . ", 0, dest, src, imm)\n";
	print VHOUT "#define dill_st${_}(c, dest, src1, src2) v_st${_}(dest, src1, src2)\n";
	print VHOUT "#define dill_st${_}i(c, dest, src1, imm) v_st${_}i(dest, src1, imm)\n";
	print IHOUT "#define dill_st${_}(c, dest, src1, src2) i_st${_}(dest, src1, src2)\n";
	print IHOUT "#define dill_st${_}i(c, dest, src1, imm) i_st${_}i(dest, src1, imm)\n";
	print HOUT "#define dill_st${_}(c, dest, src1, src2) (c->j->store)(c, DILL_" . &upperc($_) . ", 0, dest, src1, src2)\n";
	print HOUT "#define dill_st${_}i(c, dest, src, imm) (c->j->storei)(c, DILL_" . &upperc($_) . ", 0, dest, src, imm)\n";
	print VHOUT "#define dill_has_ldbs(c) 1\n";
	print VHOUT "#define dill_ldbs${_}(c, dest, src1, src2) v_ldbs${_}(dest, src1, src2)\n";
	print VHOUT "#define dill_ldbs${_}i(c, dest, src1, imm) v_ldbs${_}i(dest, src1, imm)\n";
	print IHOUT "#define dill_has_ldbs(c) 1\n";
	print IHOUT "#define dill_ldbs${_}(c, dest, src1, src2) i_ldbs${_}(dest, src1, src2)\n";
	print IHOUT "#define dill_ldbs${_}i(c, dest, src1, imm) i_ldbs${_}i(dest, src1, imm)\n";
	print HOUT "#define dill_has_ldbs(c) (c->j->bsload != 0)\n";
	print HOUT "#define dill_ldbs${_}(c, dest, src1, src2) (c->j->bsload)(c, DILL_" . &upperc($_) . ", 0, dest, src1, src2)\n";
	print HOUT "#define dill_ldbs${_}i(c, dest, src, imm) (c->j->bsloadi)(c, DILL_" . &upperc($_) . ", 0, dest, src, imm)\n";
	print HOUT "#define dill_lea(c, dest, src, imm) (c->j->lea)(c, 0, 0, dest, src, imm)\n";
    }
}

sub arith3 {
    local($ops, $types) = @_;
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print HOUT "#define dill_jmp_${op}${_} $arith3\n";
	    $enum_a3 = $enum_a3 . ", \"${op}${_}\"";
	    $poly_array{$op} = $poly_array{$op} . " ${_}";
	    $arith3 = $arith3 + 1;
	}
    }
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print VHOUT "#define dill_$op${_}(c, dest, src1, src2) v_$op${_}(dest, src1, src2)\n";
	    print VHOUT "#define dill_${op}${_}i(c, dest, src1, imm) v_$op${_}i(dest, src1, imm)\n";
	    print IHOUT "#define dill_$op${_}(c, dest, src1, src2) i_$op${_}(dest, src1, src2)\n";
	    print IHOUT "#define dill_${op}${_}i(c, dest, src1, imm) i_$op${_}i(dest, src1, imm)\n";
	    print HOUT "#define dill_$op${_}(c, dest, src1, src2) (c->j->jmp_a3)[dill_jmp_${op}${_}](c, c->j->a3_data[dill_jmp_${op}${_}].data1, c->j->a3_data[dill_jmp_${op}${_}].data2, dest, src1, src2)\n";
	    if (($_ eq 'f') || ($_ eq 'd')) {
		print HOUT "#define dill_$op${_}i(c, dest, src1, imm) (c->j->jmp_f3i)[dill_jmp_${op}${_}](c, c->j->a3f_data[dill_jmp_${op}${_}].data1, c->j->a3f_data[dill_jmp_${op}${_}].data2, dest, src1, imm)\n";
	    } else {
		print HOUT "#define dill_$op${_}i(c, dest, src1, imm) (c->j->jmp_a3i)[dill_jmp_${op}${_}](c, c->j->a3i_data[dill_jmp_${op}${_}].data1, c->j->a3i_data[dill_jmp_${op}${_}].data2, dest, src1, imm)\n";
	    }
	}
    }
}

sub arith2 {
    local($ops, $types) = @_;
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print HOUT "#define dill_jmp_${op}${_} $arith2\n";
	    $enum_a2 = $enum_a2 . ", \"${op}${_}\"";
	    $arith2 = $arith2 + 1;
	}
    }
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print VHOUT "#define dill_$op${_}(c, dest, src) v_$op${_}(dest, src)\n";
	    print VHOUT "#define dill_${op}${_}i(c, dest, imm) v_$op${_}i(dest, imm)\n";
	    print IHOUT "#define dill_$op${_}(c, dest, src) i_$op${_}(dest, src)\n";
	    print IHOUT "#define dill_${op}${_}i(c, dest, imm) i_$op${_}i(dest, imm)\n";
	    print HOUT "#define dill_$op${_}(c, dest, src) (c->j->jmp_a2)[dill_jmp_${op}${_}](c, c->j->a2_data[dill_jmp_${op}${_}].data1, c->j->a2_data[dill_jmp_${op}${_}].data2, dest, src)\n";
	    if (($_ eq 'f') || ($_ eq 'd')) {
		print HOUT "#define dill_$op${_}i(c, dest, imm) (c->j->jmp_f2i)[dill_jmp_${op}${_}](c, c->j->a2f_data[dill_jmp_${op}${_}].data1, c->j->a2f_data[dill_jmp_${op}${_}].data2, dest, imm)\n";
	    } else {
		print HOUT "#define dill_$op${_}i(c, dest, imm) (c->j->jmp_a2i)[dill_jmp_${op}${_}](c, c->j->a2_data[dill_jmp_${op}${_}].data1, c->j->a2_data[dill_jmp_${op}${_}].data2, dest, imm)\n";
	    }
	}
    }
}

sub branch {
    local($ops, $types) = @_;
    $brcode = 0;
    foreach (split(' ', $ops)) {
	print HOUT "#define dill_b${_}_code " . $brcode++ . "\n";
    }
    print COUT "char *branch_op_names[] = {";
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print HOUT "#define dill_jmp_b${op}${_} $branch\n";
	    print COUT "\"${op}${_}\", ";
	    $poly_branch_array{$op} = $poly_branch_array{$op} . " ${_}";
	    $branch = $branch + 1;
	}
    }
    print COUT "0};\n";
    foreach (split(' ', $ops)) {
	$op = $_;
	foreach (split(' ', $types)) {
	    print VHOUT "#define dill_b$op${_}(c, src1, src2, label) v_b$op${_}(src1, src2, label)\n";
	    print VHOUT "#define dill_b${op}${_}i(c, src, imm, label) v_b$op${_}i(src, imm, label)\n";
	    print IHOUT "#define dill_b$op${_}(c, src1, src2, label) i_b$op${_}(src1, src2, label)\n";
	    print IHOUT "#define dill_b${op}${_}i(c, src, imm, label) i_b$op${_}i(src, imm, label)\n";
	    print HOUT "#define dill_b$op${_}(c, src1, src2, label) (c->j->jmp_b)[dill_jmp_b${op}${_}](c, c->j->b_data[dill_jmp_b${op}${_}].data1, c->j->b_data[dill_jmp_b${op}${_}].data2, src1, src2, label)\n";
	    if (($_ eq 'f') || ($_ eq 'd')) {
		#% no immediate form 
	    } else {
		print HOUT "#define dill_b$op${_}i(c, src, imm, label) (c->j->jmp_bi)[dill_jmp_b${op}${_}](c, c->j->b_data[dill_jmp_b${op}${_}].data1, c->j->b_data[dill_jmp_b${op}${_}].data2, src, imm, label)\n";
	    }
	}
    }
}

sub convert {
    local($from_types, $to_types) = @_;
    foreach (split(' ', $from_types)) {
	$from = $_;
	foreach (split(' ', $to_types)) {
	    if (${from} eq ${_}) { 
	        next;
	    } 
	    print VHOUT "#define dill_cv${from}2${_}(c, dest, src) v_cv${from}2${_}(dest, src)\n";
	    print VHOUT "#define dill_cv${from}2${_}i(c, src, imm) v_cv${from}2${_}i(src, imm)\n";
	    print IHOUT "#define dill_cv${from}2${_}(c, dest, src) i_cv${from}2${_}(dest, src)\n";
	    print IHOUT "#define dill_cv${from}2${_}i(c, src, imm) i_cv${from}2${_}i(src, imm)\n";
	    print HOUT "#define dill_cv${from}2${_}(c, dest, src) (c->j->convert)(c, DILL_" . &upperc(${from}) . ", DILL_" . &upperc($_) . ", dest, src)\n";
	}
    }
}

sub ret {
    local($types) = @_;
    foreach (split(' ', $types)) {
	$type = $_;
	$dill_type = $_;
	if (($type eq 'c') || ($type eq 'uc') || ($type eq 's') || 
	    ($type eq 'us')) { $dill_type = "i";}
	print VHOUT "#define dill_ret${type}(c, src) v_ret${type}(src)\n";
	print VHOUT "#define dill_ret${type}i(c, imm) v_ret${type}i(imm)\n";
	print IHOUT "#define dill_ret${type}(c, src) i_ret${type}(src)\n";
	print IHOUT "#define dill_ret${type}i(c, imm) i_ret${type}i(imm)\n";
	print HOUT "#define dill_ret${type}(c, src) (c->j->ret)(c, DILL_" . &upperc($dill_type) . ", 0, src)\n";
	if ($_ eq 'p') {
	    print HOUT "#define dill_ret${type}i(c, imm) (c->j->reti)(c, DILL_" . &upperc($type) . ", 0, (unsigned long) imm)\n";
	} elsif (($_ eq 'f') || ($_ eq 'd')) {
	    print HOUT "#define dill_ret${type}i(c, imm) (c->j->retf)(c, DILL_" . &upperc($type) . ", 0, imm)\n";
	} else {
	    print HOUT "#define dill_ret${type}i(c, imm) (c->j->reti)(c, DILL_" . &upperc($type) . ", 0, imm)\n";
	}

    }
    print HOUT "#define dill_pret(c, type, src) (c->j->ret)(c, type, 0, src)\n";
}

sub mov {
    local($types) = @_;
    foreach (split(' ', $types)) {
	$type = $_;
	print VHOUT "#define dill_mov${type}(c, dest, src) v_mov${type}(dest, src)\n";
	print IHOUT "#define dill_mov${type}(c, dest, src) i_mov${type}(dest, src)\n";
	print HOUT "#define dill_mov${type}(c, dest, src) (c->j->mov)(c, DILL_" . &upperc($type) . ", 0, dest, src)\n";
    }
    print HOUT "#define dill_pmov(c, type, dest, src) (c->j->mov)(c, type, 0, dest, src)\n";
}

sub set {
    local($types) = @_;
    foreach (split(' ', $types)) {
	$type = $_;
	print VHOUT "#define dill_set${type}(c, dest, imm) v_set${type}(dest, imm)\n";
	print IHOUT "#define dill_set${type}(c, dest, imm) i_set${type}(dest, imm)\n";
	if (($_ eq 'f') || ($_ eq 'd')) {
	    print HOUT "#define dill_set${type}(c, dest, imm) (c->j->setf)(c, DILL_" . &upperc($type) . ", 0, dest, imm)\n";
	} else {
	    print HOUT "#define dill_set${type}(c, dest, imm) (c->j->set)(c, DILL_" . &upperc($type) . ", 0, dest, imm)\n";
	}
    }
    print HOUT "#define dill_piset(c, type, dest, imm) (c->j->set)(c, type, 0, dest, imm)\n";
}

sub push {
    local($types) = @_;
    print HOUT "#define dill_push_arg(c, type, reg) (c->j->push)(c, type, reg)\n";
    print HOUT "#define dill_push_init(c) (c->j->push)(c, DILL_V, -1)\n";
    foreach (split(' ', $types)) {
	$type = $_;
	print VHOUT "#define dill_push_arg${type}i(c, imm) v_push_arg${type}i(imm)\n";
	print VHOUT "#define dill_push_arg${type}(c, reg) v_push_arg${type}(reg)\n";
	print IHOUT "#define dill_push_arg${type}i(c, imm) i_arg${type}i(imm)\n";
	print IHOUT "#define dill_push_arg${type}(c, reg) i_arg${type}(reg)\n";
	print HOUT "#define dill_push_arg${type}(c, reg) (c->j->push)(c, DILL_" . &upperc($type) . ", reg)\n";
	if (($_ eq 'f') || ($_ eq 'd')) {
	    print HOUT "#define dill_push_arg${type}i(c, imm) (c->j->pushfi)(c, DILL_" . &upperc($type) . ", imm)\n";
	} elsif ($_ eq 'p') {
	    print HOUT "#define dill_push_arg${type}i(c, imm) (c->j->pushpi)(c, DILL_" . &upperc($type) . ", imm)\n";
	} else {
	    print HOUT "#define dill_push_arg${type}i(c, imm) (c->j->pushi)(c, DILL_" . &upperc($type) . ", imm)\n";
	}
    }
}

sub call {
    local($types) = @_;
    foreach (split(' ', $types)) {
	$type = $_;
	if ($type eq 'v') {
	    print HOUT "extern void dill_scall${type}(dill_stream c, void *ptr, char *arg_str, ...);\n";
	} else {
	    print HOUT "extern int dill_scall${type}(dill_stream c, void *ptr, char *arg_str, ...);\n";
	}
	print HOUT "#define dill_call${type}(c, ptr) c->j->calli(c, DILL_" . &upperc($type) . " , ptr)\n";
	print HOUT "#define dill_callr${type}(c, src) c->j->callr(c, DILL_" . &upperc($type) . " , src)\n";
	print VHOUT "#define dill_call${type}(c, ptr) v_ccall${type}(ptr)\n";
	print IHOUT "#define dill_call${type}(c, ptr) i_call${type}i(ptr)\n";
    }
    print HOUT "#define dill_pcall(c, type, ptr) c->j->calli(c, type, ptr)\n";
    print HOUT "#define dill_pcallr(c, type, src) c->j->callr(c, type, src)\n";
}

sub save_restore {
    local($types) = @_;
    foreach (split(' ', $types)) {
	$type = $_;
	print HOUT "#define dill_save${type}(c, reg) c->j->save_restore(c, 0, DILL_" . &upperc($_) . ", reg)\n";
	print HOUT "#define dill_restore${type}(c, reg) c->j->save_restore(c, 1, DILL_" . &upperc($_) . ", reg)\n";
	print VHOUT "#define dill_save${type}(c, reg) v_save${type}(reg)\n";
	print VHOUT "#define dill_restore${type}(c, reg) v_restore${type}(reg)\n";
	
    }
}

sub init_output {
    open(HOUT, '>dill.h') || die "Can't open header output";
    open(COUT, '>dill.c') || die "Can't open C output";

print HOUT<<EOF;
#ifndef __DILL_H__
#define __DILL_H__

/* This file is generated from base.ops.  Do not edit directly. */

#if defined(__cplusplus) || defined(c_plusplus)
extern "C" {
#endif

struct dill_private_ctx;

typedef struct dill_private_ctx *private_ctx;

struct jmp_table_s;

typedef struct jmp_table_s *jmp_table;

typedef struct dill_stream_s {
    jmp_table j;
    private_ctx p;
    int dill_local_pointer;
    int dill_param_reg_pointer;
    int dill_debug;
}*dill_stream;

struct dec;

typedef struct dec *dill_exec_ctx;

typedef int dill_reg;

typedef enum {DILL_NOP = 0, DILL_SEGMENTED_FOLLOWS} special_operations;
typedef enum {DILL_X86_CS_PREFIX = 0, DILL_X86_SS_PREFIX,
              DILL_X86_DS_PREFIX, DILL_X86_ES_PREFIX,
              DILL_X86_FS_PREFIX, DILL_X86_GS_PREFIX} segment_prefix;

typedef void (*dill_mach_init_routine)(dill_stream c);
typedef void (*dill_mach_proc_start)(dill_stream c, char *name, int param_count, void *params, dill_reg *arg_reg_list);
typedef void (*dill_mach_end)(dill_stream c);
typedef void *(*dill_mach_clone_code)(dill_stream c, void *new_base, int size);
typedef void (*arith_op3)(dill_stream c, int data1, int data2, int dest, int src1, int src2);
typedef void (*arith_op3i)(dill_stream c, int data1, int data2, int dest, int src1, long imm);
typedef void (*arith_op3fi)(dill_stream c, int data1, int data2, int dest, int src1, double imm);
typedef void (*arith_op2)(dill_stream c, int data1, int data2, int dest, int src);
typedef void (*arith_op2i)(dill_stream c, int data1, int data2, int dest, long imm);
typedef void (*branch_op)(dill_stream c, int data1, int data2, int src1, int src2, int label);
typedef void (*branch_opi)(dill_stream c, int data1, int data2, int src, long imm, int label);
typedef void (*cvt_op)(dill_stream c, int data1, int data2, int dest, int src);
typedef void (*cvt_opi)(dill_stream c, int data1, int data2, int dest, long imm);
typedef void (*ldst_op)(dill_stream c, int data1, int data2, int dest, int src1, int src2);
typedef void (*ldst_opi)(dill_stream c, int data1, int data2, int dest, int src1, long imm);
typedef void (*ret_op)(dill_stream c, int data1, int data2, int src);
typedef void (*ret_opi)(dill_stream c, int data1, int data2, long imm);
typedef void (*ret_opf)(dill_stream c, int data1, int data2, double imm);
typedef void (*jmp_op)(dill_stream c, unsigned long arg);
typedef void (*jmp_opa)(dill_stream c, void *arg);
typedef void (*jal_op)(dill_stream c, int dest, int target);
typedef void (*special_op)(dill_stream c, special_operations type, long param);
typedef int (*call_opi)(dill_stream c, int type, void *xfer_address);
typedef int (*call_opr)(dill_stream c, int type, int src);
typedef void (*setf_opi)(dill_stream c, int data1, int data2, int dest, double imm);
typedef void (*push_op)(dill_stream c, int type, int reg);
typedef void (*push_opi)(dill_stream c, int type, long value);
typedef void (*push_oppi)(dill_stream c, int type, void *value);
typedef void (*push_opfi)(dill_stream c, int type, double value);
typedef int (*local_op)(dill_stream c, int flag, int val);
typedef void (*save_restore_op)(dill_stream c, int save_restore_flag, int type, int reg);
typedef void (*lea_op)(dill_stream c, int data1, int data2, int dest, int src, long offset);
typedef int (*init_disassembly_op)(dill_stream c, void *dis_info);
typedef int (*print_insn_op)(dill_stream c, void *dis_info, void *insn);
typedef void (*print_reg_op)(dill_stream c, int typ, int reg);
typedef int (*count_insn_op)(dill_stream c, int start, int end);

typedef struct jmp_data_s {
    short data1;
    short data2;
} jmp_data;

struct jmp_table_s {
    dill_mach_init_routine init;
    dill_mach_proc_start proc_start;
    dill_mach_end end;
    dill_mach_clone_code clone_code;
    int *type_align;
    arith_op3 *jmp_a3;
    jmp_data *a3_data;
    arith_op3i *jmp_a3i;
    jmp_data *a3i_data;
    arith_op3fi *jmp_f3i;
    jmp_data *f3i_data;
    arith_op2 *jmp_a2;
    arith_op2i *jmp_a2i;
    jmp_data *a2_data;
    branch_op *jmp_b;
    branch_opi *jmp_bi;
    jmp_data *b_data;
    cvt_op convert;
    ldst_op load;
    ldst_op bsload;
    ldst_opi loadi;
    ldst_opi bsloadi;
    ldst_op store;
    ldst_opi storei;
    ret_op ret;
    ret_opi reti;
    ret_opf retf;
    arith_op2 mov;
    arith_op2i set;
    setf_opi setf;
    jmp_op jv;
    jmp_op jp;
    jmp_opa jpi;
    jal_op jal;
    special_op special;
    call_opi calli;
    call_opr callr;
    push_op push;
    push_opi pushi;
    push_opfi pushfi;
    push_oppi pushpi;
    local_op local;
    save_restore_op save_restore;
    
    init_disassembly_op init_disassembly;
    print_insn_op print_insn;
    print_reg_op print_reg;
    count_insn_op count_insn;
    int do_reverse_push;
    int *type_size;
    lea_op lea;
    int target_byte_order;
    int target_float_format;
};

typedef struct { 
    int is_register;		/* true if parameter is in register */
    unsigned reg;		/* register it's in */
    int offset;			/* otherwise at this offset from stack */
} dill_parameter_type;
#if defined(_MSC_VER)
#ifdef DILL_EXPORTS
#define EXTERN extern __declspec(dllexport)
#else
#define EXTERN extern __declspec(dllimport)
#endif
#else
#define EXTERN extern
#endif

extern jmp_table sparc_jump_table;
EXTERN dill_stream dill_create_raw_stream(void);
EXTERN dill_stream dill_create_stream(void);
EXTERN dill_exec_ctx dill_get_exec_context(dill_stream x);
EXTERN void dill_free_context(dill_stream c);
EXTERN void dill_free_exec_context(dill_exec_ctx c);
EXTERN void dill_assoc_client_data(dill_exec_ctx ec, int key, long value);
EXTERN long dill_get_client_data(dill_exec_ctx ec, int key);
EXTERN void* dill_take_code(dill_stream c);
EXTERN int dill_alloc_label(dill_stream c);
EXTERN void dill_mark_label(dill_stream c, int label);
EXTERN void dill_mark_data(dill_stream c, void *addr, int label);
EXTERN int dill_raw_getreg(dill_stream c, dill_reg *reg_p, int type, int reg_class);
EXTERN int dill_getreg(dill_stream c, int typ);
EXTERN void dill_raw_putreg(dill_stream c, dill_reg reg_p, int type);
EXTERN void dill_raw_unavailreg(dill_stream c, int type, dill_reg reg);
EXTERN void dill_raw_availreg(dill_stream c, int type, dill_reg reg);
EXTERN void dill_alloc_specific(dill_stream c, dill_reg reg_p, int type, int reg_class);
EXTERN void dill_dealloc_specific(dill_stream c, dill_reg reg_p, int type, int reg_class);
EXTERN void dill_start_simple_proc(dill_stream c, char *name, int ret_type);
EXTERN void dill_param_alloc(dill_stream c, int argno, int type, 
			  dill_reg *regp);
EXTERN void dill_param_struct_alloc(dill_stream c, int argno, int type, 
				 dill_parameter_type *paramp);
EXTERN dill_reg dill_param_reg(dill_stream c, int argno);
EXTERN dill_reg dill_vparam(dill_stream c, int argno);
EXTERN void dill_start_proc(dill_stream c, char *name, int ret_type, char *arg_str);
EXTERN void dill_dump(dill_stream c);
EXTERN void *dill_end(dill_stream c);
EXTERN void *dill_clone_code(dill_stream c, void *new_base, int size);
EXTERN int dill_code_size(dill_stream c);
EXTERN int dill_do_reverse_vararg_push(dill_stream c);
EXTERN int dill_getvblock(dill_stream c, int size);
EXTERN void dill_virtual_lea(dill_stream c, int dest, int src);
EXTERN void dill_pbr(dill_stream c, int op_type, int data_type, dill_reg src1, 
		   dill_reg src2, int label);

#define dill_type_align(c, t) c->j->type_align[t]
#define dill_type_size(c, t) c->j->type_size[t]
#define dill_target_byte_order(c) c->j->target_byte_order
#define dill_target_float_format(c) c->j->target_float_format
#define dill_lp(c) c->dill_local_pointer
#define dill_pp(c) c->dill_param_reg_pointer
#define dill_local(c, type) c->j->local(c, 0, type)
#define dill_localb(c, bytes) c->j->local(c, 1, bytes)


/* atomic types */
enum {
    DILL_C,    /* char */
    DILL_UC,   /* unsigned char */
    DILL_S,    /* short */
    DILL_US,   /* unsigned short */
    DILL_I,    /* int */
    DILL_U,    /* unsigned */
    DILL_L,    /* long */
    DILL_UL,   /* unsigned long */
    DILL_P,    /* pointer */
    DILL_F,    /* floating */
    DILL_D,    /* double */
    DILL_V,    /* void */
    DILL_B,    /* block structure */
    DILL_EC,   /* execution context */
    DILL_ERR   /* no type */
};

enum {DILL_VAR, DILL_TEMP};

EOF

}
